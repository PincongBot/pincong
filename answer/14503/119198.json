{"type":"answer","id":119198,"parentType":"question","parentId":14503,"uid":25234,"contents":"反对 @一只bug 的说法。应该说：tg做这些没有意义。<br>\n<br>\n为什么？<br>\n<br>\n1. 因为加密的代价已经过于低廉。党可以立法，但是不可能禁止用户自己给自己的数据做什么。<br>\n<br>\n2. <a href=\"https://github.com/openpgpjs/openpgpjs/blob/master/dist/openpgp.js\" rel=\"nofollow noreferrer noopener\" target=\"_blank\">https://github.com/openpgpjs/openpgpjs/blob/master/dist/openpgp.js</a> 用JavaScript编写的全功能 OpenPGP 代码，只有1.42兆，你现在就可以下载下来。有了这个，你永远可以和朋友加密通信（但这个代码只是一个软件库，除非你能自己写代码运用它：不必担心，真到了那一天， 会做这个的人比比皆是）。<br>\n<br>\n3. 退一万步，如果连 AES 这种国际标准的加密算法都禁止使用了，甚至所有的加密算法都被禁止，我们仍然可以使用散列函数构建安全的对称加密算法（具体办法是仿照ChaCha20这样的算法，用散列函数构建随机数发生器，将散列函数变成流加密密码；同一个函数还可用来构建消息认证码）。（甚至即将淘汰的SHA-1在这一用途上也还是安全的）这样做不能进行基于公钥的通信，不过如果双方事先约定了密钥，还是可以的。<br>\n<br>\n下面这段代码，就是 Salsa20 这个加密算法的核心函数。你现在就可以拍照留念。只要有这个，我们就可以很快地构建出Salsa20这个加密算法，它的安全性是有证明的。<br>\n<br>\n<pre>&nbsp; &nbsp;&nbsp; #define R(a,b) (((a) &lt;&lt; (b)) | ((a) &gt;&gt; (32 - (b))))<br>\n&nbsp; &nbsp;&nbsp; void salsa20_word_specification(uint32 out[16],uint32 in[16])<br>\n&nbsp; &nbsp;&nbsp; {<br>\n&nbsp; &nbsp; &nbsp;&nbsp; int i;<br>\n&nbsp; &nbsp; &nbsp;&nbsp; uint32 x[16];<br>\n&nbsp; &nbsp; &nbsp;&nbsp; for (i = 0;i &lt; 16;++i) x[i] = in[i];<br>\n&nbsp; &nbsp; &nbsp;&nbsp; for (i = 20;i &gt; 0;i -= 2) {<br>\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; x[ 4] ^= R(x[ 0]+x[12], 7);&nbsp; x[ 8] ^= R(x[ 4]+x[ 0], 9);<br>\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; x[12] ^= R(x[ 8]+x[ 4],13);&nbsp; x[ 0] ^= R(x[12]+x[ 8],18);<br>\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; x[ 9] ^= R(x[ 5]+x[ 1], 7);&nbsp; x[13] ^= R(x[ 9]+x[ 5], 9);<br>\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; x[ 1] ^= R(x[13]+x[ 9],13);&nbsp; x[ 5] ^= R(x[ 1]+x[13],18);<br>\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; x[14] ^= R(x[10]+x[ 6], 7);&nbsp; x[ 2] ^= R(x[14]+x[10], 9);<br>\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; x[ 6] ^= R(x[ 2]+x[14],13);&nbsp; x[10] ^= R(x[ 6]+x[ 2],18);<br>\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; x[ 3] ^= R(x[15]+x[11], 7);&nbsp; x[ 7] ^= R(x[ 3]+x[15], 9);<br>\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; x[11] ^= R(x[ 7]+x[ 3],13);&nbsp; x[15] ^= R(x[11]+x[ 7],18);<br>\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; x[ 1] ^= R(x[ 0]+x[ 3], 7);&nbsp; x[ 2] ^= R(x[ 1]+x[ 0], 9);<br>\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; x[ 3] ^= R(x[ 2]+x[ 1],13);&nbsp; x[ 0] ^= R(x[ 3]+x[ 2],18);<br>\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; x[ 6] ^= R(x[ 5]+x[ 4], 7);&nbsp; x[ 7] ^= R(x[ 6]+x[ 5], 9);<br>\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; x[ 4] ^= R(x[ 7]+x[ 6],13);&nbsp; x[ 5] ^= R(x[ 4]+x[ 7],18);<br>\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; x[11] ^= R(x[10]+x[ 9], 7);&nbsp; x[ 8] ^= R(x[11]+x[10], 9);<br>\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; x[ 9] ^= R(x[ 8]+x[11],13);&nbsp; x[10] ^= R(x[ 9]+x[ 8],18);<br>\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; x[12] ^= R(x[15]+x[14], 7);&nbsp; x[13] ^= R(x[12]+x[15], 9);<br>\n&nbsp; &nbsp; &nbsp; &nbsp;&nbsp; x[14] ^= R(x[13]+x[12],13);&nbsp; x[15] ^= R(x[14]+x[13],18);<br>\n&nbsp; &nbsp; &nbsp;&nbsp; }<br>\n&nbsp; &nbsp; &nbsp;&nbsp; for (i = 0;i &lt; 16;++i) out[i] = x[i] + in[i];<br>\n&nbsp; &nbsp;&nbsp; }</pre><br>\n<br>\n<br>\n4. 学术上正在讨论用散列函数构建公钥签名算法，如果这一算法得到优化，至少可以不必担心数字签名的问题（虽然这一点看起来和隐私有点无关，但是数字签名却能保证你下载的软件是完整、没有被第三者加入后门的）。<br>\n<br>\n5. 对称加密和散列函数的破解难度，是无法用量子计算机显著降低的。量子计算机只能把 AES-256 的256比特安全性降低到一半，但128比特安全性还是足以保护你的数据（就是在你有生之年无法破解的程度）。<br>\n<br>\n<br>\n作为最终的用户，想要加密自己离线的隐私数据，目前最好的方案还是转用 Linux。当前 Fedora、Debian、Ubuntu 等操作系统在安装过程中都提供了设置全磁盘加密的选项。有了这个，就算你的硬盘落入警察手中，他们也无法破解。（但你仍然要考虑被逼供的问题）","date":"2020-01-02","agreeCount":2,"discussionCount":1}