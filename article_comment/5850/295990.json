{"type":"article_comment","id":295990,"parentType":"article","parentId":5850,"uid":18160,"contents":"<blockquote>vmess除了协议头那个hash和指令加密，还会对数据长度进行混淆。TLS的padding也是这个原...</blockquote><br>\n<br>\n<br>\n一个个回答吧。。。<br>\nvmess的余量P代码在v2ray-core\\proxy\\vmess\\encoding\\client.go<br>\nEncodeRequestHeader 这个函数里<br>\npadingLen := dice.Roll(16) // 得到一个随机数作为padding len<br>\nbuffer.Write([]byte{security, byte(0), byte(header.Command)})) //拼报文头里的padding长度<br>\nbuffer.ReadFullFrom(rand.Reader, int32(padingLen))) //写入了padding长度的随机字符串<br>\n人话版本：每次随机一个数字作为余量P写到报文头，然后生成随机字符串<br>\n目的我猜是为了让报文头不是定长，且随机<br>\n<br>\n另外，你看protocol.RequestOptionGlobalPadding 这个配置项<br>\n代码路径 v2ray-core\\common\\crypto\\auth.go<br>\n看函数seal里的实现<br>\nbody部分也会有额外的padding，但是长度来自<br>\npaddingSize = int32(w.padding.NextPaddingLen())<br>\n然后末尾填充<br>\npaddingBytes := eb.Extend(paddingSize)<br>\ncommon.Must2(rand.Read(paddingBytes))<br>\n<br>\n再说下TLS的padding<br>\n看RFC <br>\nhttps://tools.ietf.org/html/rfc7685<br>\nhttps://tools.ietf.org/html/rfc5246<br>\n读到下面这句话<br>\nPadding that is added to force the length of the plaintext to be<br>\nan integral multiple of the block cipher's block length<br>\npadding是为了强制明文长度是cipher's block长度的整数倍！<br>\n<br>\n代码实现<br>\nopenssl的ssl\\t1_lib.cc里<br>\nssl_add_clienthello_tlsext这个函数<br>\n还有openssl的ssl\\tls_record.cc里<br>\ntls_seal_record这个函数<br>\n具体就是填充报文而已。。。<br>\n<br>\n最后谈下padding攻击<br>\nhttps://en.wikipedia.org/wiki/Padding_oracle_attack<br>\nhttps://www.tripwire.com/state-of-security/vert/tls-cbc-padding-oracles/<br>\nhttps://wooyun.js.org/drops/SSL.TLS%E5%8D%8F%E8%AE%AE%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97%EF%BC%9ASSL%E7%9A%84Padding%20Oracle%E6%94%BB%E5%87%BB.html<br>\n<br>\n迷雾通，代码貌似默认基于UDP的，我猜。。。还没看完<br>\nUDP的好处就是不用握手，没法RST。TCP毕竟会被RST，不方便<br>\n我比较忙，看这个得抽点时间，没有那么快，你着急，可以找作者直接问他。。。","date":"2020-03-14","agreeCount":1,"discussionCount":0}