{"type":"article_comment","id":301200,"parentType":"article","parentId":5850,"uid":18160,"contents":"講起來，還很費勁。。。<br>\n<br>\n先講下keygen吧，密鑰生成<br>\n這裏有兩個步驟<br>\n1&gt;<b>参数生成paramgen</b><br>\na) pctx = EVP_PKEY_CTX_new_id(EVP_PKEY_EC, NULL) 調用init函數分配内存<br>\nb) EVP_PKEY_CTX_set_ec_paramgen_curve_nid(pctx, NID_sm2p256v1) 調用的是ctrl函數<br>\n只是針對ec這個文件，專門調用這個而已，設置dctx-&gt;gen_group<br>\nc) EVP_PKEY_paramgen(pctx, &amp;params) 調用對應pmeth裏的paramgen函數<br>\n比如pkey_ec_paramgen，生成的參數放到params裏<br>\n内部邏輯如下：<br>\nEC_KEY *ec = EC_KEY_new();<br>\nEC_KEY_set_group(ec, dctx-&gt;gen_group)<br>\nEVP_PKEY_assign_EC_KEY(pkey, ec);<br>\n<br>\n2&gt;<b>密鑰生成keygen</b><br>\nkctx = EVP_PKEY_CTX_new(params, NULL)<br>\nEVP_PKEY_keygen_init(kctx) ctx-&gt;operation = EVP_PKEY_OP_KEYGEN<br>\nEVP_PKEY_keygen(kctx, &amp;key)<br>\n調用 keygen函數，生成密鑰<br>\n内部邏輯如下：<br>\nEC_KEY *ec = EC_KEY_new();<br>\nEC_KEY_set_group(ec, group)<br>\nEC_KEY_generate_key(ec) <br>\nEVP_PKEY_assign_EC_KEY(pkey, ec);<br>\n<br>\n重點函數在EC_KEY_generate_key 這裏！<br>\n先用ec_wrapped_scalar_new 隨機找一個數作爲私鑰priv_key<br>\n然後用EC_POINT_new 找一個點作爲公鑰pub_key<br>\n<br>\n總結，先paramgen生成參數，再keygen生成公鑰和私鑰<br>\n------------------------------------------------------------<br>\n接下來是協商密鑰。。。<br>\nctx = EVP_PKEY_CTX_new(pkey);其中pkey來自上面生成的内容<br>\nEVP_PKEY_derive_init(ctx)&nbsp;&nbsp;&nbsp; <br>\nEVP_PKEY_derive_set_peer(ctx, peerkey)&nbsp;&nbsp; 其中peerkey是對端的pkey，有對端公鑰就可以了，不需要私鑰<br>\nEVP_PKEY_derive(ctx, NULL, &amp;skeylen) 計算密鑰長度<br>\nskey = OPENSSL_malloc(skeylen);<br>\nEVP_PKEY_derive(ctx, skey, &amp;skeylen) 得到我需要的共享密鑰，也就是AES密鑰<br>\nec为例，pkey_ec_derive，调用了ECDH_compute_key<br>\n<br>\nAES密鑰是爲了後續的對稱加密<br>\n整個過程，中間人只能抓包獲得兩邊的公鑰，得不到私鑰，非常安全<br>\n公鑰和私鑰都是動態生成的，也就是每次都不一樣，這個保證了密碼的前向安全<br>\nRSA是靜態密鑰，寫死了。。。<br>\n<br>\n非常安全！<br>\n<br>\n<br>\n開始總結<br>\nstruct evp_pkey_method_st {<br>\n&nbsp; int pkey_id; 加密類型， 比如rsa ec等<br>\n<br>\n&nbsp; int (*init)(EVP_PKEY_CTX *ctx); 沒什麽用，分配ctx的時候，malloc内存<br>\n&nbsp; int (*copy)(EVP_PKEY_CTX *dst, EVP_PKEY_CTX *src);<br>\n&nbsp; void (*cleanup)(EVP_PKEY_CTX *ctx);<br>\n<br>\n&nbsp; int (*keygen)(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey); 生成密鑰<br>\n<br>\n&nbsp; int (*sign)(EVP_PKEY_CTX *ctx, uint8_t *sig, size_t *siglen,<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const uint8_t *tbs, size_t tbslen); 數字簽名<br>\n<br>\n&nbsp; int (*sign_message)(EVP_PKEY_CTX *ctx, uint8_t *sig, size_t *siglen,<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const uint8_t *tbs, size_t tbslen);<br>\n<br>\n&nbsp; int (*verify)(EVP_PKEY_CTX *ctx, const uint8_t *sig, size_t siglen,<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const uint8_t *tbs, size_t tbslen); 驗證數字簽名<br>\n<br>\n&nbsp; int (*verify_message)(EVP_PKEY_CTX *ctx, const uint8_t *sig, size_t siglen,<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const uint8_t *tbs, size_t tbslen);<br>\n<br>\n&nbsp; int (*verify_recover)(EVP_PKEY_CTX *ctx, uint8_t *out, size_t *out_len,<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const uint8_t *sig, size_t sig_len);<br>\n<br>\n&nbsp; int (*encrypt)(EVP_PKEY_CTX *ctx, uint8_t *out, size_t *outlen,<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const uint8_t *in, size_t inlen); RSA之類的加密消息用的<br>\n<br>\n&nbsp; int (*decrypt)(EVP_PKEY_CTX *ctx, uint8_t *out, size_t *outlen,<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; const uint8_t *in, size_t inlen); RSA之類的解密消息<br>\n<br>\n&nbsp; int (*derive)(EVP_PKEY_CTX *ctx, uint8_t *key, size_t *keylen);密鑰分發<br>\n<br>\n&nbsp; int (*paramgen)(EVP_PKEY_CTX *ctx, EVP_PKEY *pkey); 參數生成<br>\n<br>\n&nbsp; int (*ctrl)(EVP_PKEY_CTX *ctx, int type, int p1, void *p2); 設置自定義參數<br>\n} /* EVP_PKEY_METHOD */;<br>\n<br>\n<br>\n密鑰生成和密鑰協商已經講完了<br>\n如果大家想聽數字簽名，我再額外講講。。。<br>\n至於加密解密，其實沒有什麽意義，現在沒人用了","date":"2020-03-17","agreeCount":2,"discussionCount":0}