{"type":"article_comment","id":274794,"parentType":"article","parentId":5850,"uid":18160,"contents":"现在谈下加密<br>\n先讲下异或吧，1^1=0 0^0=0 0^1=1 1^0=1<br>\n总结 a和b不同就是1 否则是0<br>\n<br>\n第一章： 对称加密<br>\n代表算法AES 、chacha20<br>\n算法的原理，就不说了。就说具体操作抽象一下来讲，就是用密钥去<b>异或</b>加密字符串<br>\n加密过程，大概就是 密钥 ^ 明文 = 密文 ，不够就 for 循环 这个过程，直到整个明文都被加密<br>\n<br>\n解密过程，大概就是 密文 ^ 密钥 = 明文， 因为异或的算法特性，所以可以得到明文<br>\n这个过程，加密和解密的密钥是同一个，所以叫做对称加密<br>\n<br>\n我们平时上网，数据的加密都是用AES这样的对称加密算法加密的，手机端【老旧cpu】使用的是chacha20<br>\n<br>\n第二章：非对称加密<br>\n代表算法RSA<br>\n对称加密算法是用来<b>加密数据</b>的<br>\n这个加密算法，不是用来加密数据的，是用来<b>加密密钥</b>的！<br>\n举个例子，我和AAA需要沟通，而且内容机密，得给他一个AES密钥，所以我得把密钥加密以后再给AAA<br>\n而不是直接给他AES的明文密钥<br>\n过程如下【抽象版本】<br>\n1.我告诉AAA，我们来生成一对密钥吧【第一次握手，client hello】<br>\n2.AAA给我一个很大很大的质数【第二次握手，server hello】<br>\n3.我根据AAA的质数，生成一对公钥和私钥，把公钥发给AAA【第三次握手，send 公钥】<br>\n4.AAA回复我，收到你的公钥了！【send 公钥 ack】<br>\n5.我自己在生成一个aes的密钥，用私钥加密以后发给了AAA【send aes 密钥】<br>\n6.aaa收到以后用公钥解密，得到aes密钥【send aes 密钥 ack】<br>\n之后的通信都是aes加密以后的了<br>\n<br>\n公钥加密以后，有私钥的人才能知道发的内容！<br>\n哪怕第三方截获了我和AAA的公钥和密文，也没有办法知道AAA给我发了什么。<br>\n<br>\n第三章：数据摘要<br>\n代表算法md5 、sha256<br>\n为了防止数据篡改，或者数据发送过程中丢失，乱序等情况<br>\n我们会对数据发送的时候做一次数据摘要！<br>\n大致过程【抽象版本】<br>\n第一种：<br>\n先对明文做md5，得到一个hash<br>\n然后明文后面拼上这个hash，一起aes加密得到密文<br>\n接收方，可以得到密文后先aes解密，在对明文算一次hash，和刚才得到的hash比对，是否一致<br>\n第二种：<br>\n反过来，先对明文aes加密，然后对密文算一次hash<br>\n接收方，略。。<br>\n然后，这些都不安全<br>\n于是乎，提出了AEAD<br>\n举例算法 aes-gcm、chacha20-poly1305<br>\n同时对明文aes加密和算hash，得到的字符串拼在一起<br>\n<br>\nAEAD【AES128-GCM】翻墙必备！！！<br>\n<br>\n<br>\n第四章：cert证书机制<br>\n代表 x.509v3<br>\n举个例子，我和AAA通信的时候，凭什么相信对方是AAA呢？<br>\n所以需要一个第三方中间人，来证明AAA是AAA！<br>\n这个中间人叫根证书【中共一直在安卓和iOS，Windows，Chrome里添加自己的根证书】<br>\n模拟过程【抽象版本】<br>\n我问AAA，你是谁？<br>\nAAA给了我它的证书<br>\n我拿AAA给我的证书去问根证书，这个人是真的AAA么？<br>\n根证书校验了AAA的证书以后，告诉我是或者不是，<br>\n如果是的话，我就和AAA继续聊天了，否则我选择不聊天！<br>\n<br>\n这里，我觉得太长了，有空给你们补课。<br>\n亦或者，你们不懂的地方说出来，我单独回答","date":"2020-02-29","agreeCount":2,"discussionCount":0}