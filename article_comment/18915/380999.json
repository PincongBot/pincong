{"type":"article_comment","id":380999,"parentType":"article","parentId":18915,"uid":18160,"contents":"https://youtu.be/dpMVLrdzhuY<br>\n聽説下雨天，音樂和代碼更配哦~<br>\n<br>\n輸入特徵也很重要的好麽。。。<br>\n你們都不看。。。<br>\n都只看網絡結構，和訓練的loss函數，優化器，調參。。。<br>\n<br>\n先介紹下輸入特徵的情況<br>\n前向過程：<br>\n原版AlphaGo的 輸入特徵函數 是 extractState<br>\n&nbsp;現在的 Zero版本 ，輸入特徵函數 是 extractStateAGZ<br>\n<br>\n反向過程，訓練的時候<br>\n如果是原版 看函數 extractStateExt<br>\n如果是 zero版本 ，看 extractStateExtAGZ<br>\n--------------------------------------------------------<br>\n問題1：什麽時候會調用這4個函數呢？<br>\n前向過程：<br>\nsrc_cpp\\elf\\ai\\tree_search\\tree_search.h 【從MCTS 開始讀起】<br>\nMCTS樹搜索的時候會執行&nbsp; actor.evaluate(locked_states, &amp;resps);【actor是 MCTSActor】<br>\n内部代碼 執行了 ai_-&gt;act_batch(p_bfs, p_replies) 【ai_ 是 elf::ai::AIClientT&lt;BoardFeature, GoReply&gt;】<br>\nact_batch 内部代碼 執行了 client_-&gt;sendBatchWait(targets_, ptr_funcs_s);<br>\n也就是通知Python，這個時候會調用 Python的回調 函數 <br>\n然後發現 參數列表 是 &lt;BoardFeature, GoReply&gt;<br>\n所以Python側代碼 會調用 <br>\nsrc_cpp\\elf\\base\\sharedmem.h<br>\n的 state2mem函數&nbsp; datum-&gt;state_to_mem_funcs.transfer(idx, mem);<br>\np.second(*anyp, msg_idx); <br>\n其中p.first 表示了類型 這裏就是&nbsp; BoardFeature<br>\n所以 p.second 表示了 extractStateAGZ 【這裏用了 std::bind來封裝】<br>\n<br>\n反向過程：<br>\nsrc_cpp\\elfgames\\go\\train\\game_train.cc<br>\n兩種情況，一種是從本地的json文件裏去讀取游戲歷史記錄<br>\n第二種是通過zmq收到數據去處理<br>\n先説第二種<br>\n收到 zmq的數據以後 ，調用 _state_ext[i]-&gt;fromRecord(*r);<br>\n得到了state數據，注意，這個時候，參數類型是 &lt;GoStateExtOffline&gt;<br>\n回到剛才的講解 ，所以 調用了 extractStateExtAGZ 了<br>\n<br>\nBindStateToStateToMemFunc 這個函數給 函數綁了個入參<br>\n而 transfer綁的是出參<br>\n<br>\n問題2：這4個函數内部實現講解？<br>\nsrc_cpp\\elfgames\\go\\base\\board_feature.cc<br>\n實現的void BoardFeature::extractAGZ(float* features) const <br>\n看看就好，明天繼續寫","date":"2020-05-17","agreeCount":0,"discussionCount":0}