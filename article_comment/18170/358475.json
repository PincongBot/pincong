{"type":"article_comment","id":358475,"parentType":"article","parentId":18170,"uid":18160,"contents":"人話版本：<br>\n前面講解，估計很多人聽不懂。我還是總結下吧~<br>\n<br>\n客戶端，向Binder服務器發送請求，獲得了網橋的IP端口，cookie等信息【通過CDN，所以不能墻】<br>\n客戶端，根據剛獲得的網橋地址，去TCP連接，中間過程是加密的【對GFW是明文~但是只能知道公鑰】<br>\n客戶端，收到服務器應答，得到服務器公鑰，中間過程是加密的【對GFW是明文~但是只能知道公鑰】<br>\n客戶端，通過ECC計算得到最終的密鑰，通過此密鑰傳輸數據【對GFW是密文】<br>\n<br>\n第三篇，講解的是tinyss~<br>\n<br>\n給讀者的建議：<br>\ndialBridge 明明可以直接連接網橋的IP端口地址，作者卻在代碼裏，截斷了【端口字符串】，改成客戶端本地隨機產生端口，然後讓用戶一個個去試【PoW啊~】，你們可以修改這個函數，就不用一個個端口測試過來了<br>\n<br>\n給作者的建議：<br>\n我建議cookie不要使用rand，而使用ECC公鑰！<br>\n我自己的設計如下：<br>\n1.網橋 通過 ECC生成自己的公鑰 和 私鑰<br>\n2.把公鑰 按 你現在的cookie方式 發給binder<br>\n3.客戶端 按 你現在的方式，獲得網橋信息和 網橋的ECC公鑰【你的cookie】<br>\n4.客戶端調用cshirt2 的client，自己用得到的cookie和自己的私鑰，直接得到對稱密鑰ss<br>\n5.再用 cookie為key，計算mac256（cookie， ss），得到cshirt2層的 chacha20的密鑰<br>\n6.客戶端 發送 【自己的公鑰[明文] +&nbsp; chacha20(\"conn/feedback\" + exitName)[密文]】<br>\n---------------<br>\n服務端收到，客戶端報文，前32個字節就是公鑰，計算得到密鑰，解密33字節開始的報文<br>\n。。。<br>\n<br>\n整個過程，只需要客戶端明文發送公鑰，其他所有流量全是加密數據<br>\n對GFW而言，所有流量都是全程加密的，而且握手協議比你現在的簡單很多<br>\n以上過程，我是模仿火狐的【DoH + ESNI】，你的binder服務器，我就當是DoH服務器了<br>\nDNS返回的txt record，也就是你的cookie<br>\n<br>\n<br>\n<br>\n你的dialBridge函數，使用隨機端口，除了欺負下不懂代碼的用戶，我感覺沒有任何用處。。。","date":"2020-04-26","agreeCount":10,"discussionCount":0}