{"type":"video_comment","id":17746,"parentType":"video","parentId":1872,"uid":18160,"contents":"<center><b>0x2 詳細設計</b></center><br>\n2.1 我們實現第一部分，新建一個虛擬網卡<br>\n這裏有兩種手段，第一種，我們稱爲内核態，第二種，我們稱爲用戶態；<br>\n希望通過内核態實現的人，去讀https://github.com/torvalds/linux/tree/master/drivers/net/wireguard<br>\n文件是device.c<br>\n<b>我比較懶</b>，沒那麽多時間教大家内核態開發。。。<br>\n<br>\n我們直接從簡單的入手吧~<br>\n我們用<b>用戶態</b>來實現，很簡單，就一句話~<br>\nint fd = open(\"/dev/net/tun\", O_RDWR);<br>\n<br>\n搞定，我們得到了一個虛擬網卡~<br>\n是不是很容易？ 經過我實際測試，個別操作系統的路徑不一定是<br>\n/dev/net/tun,可能是/dev/tun，所以，大家根據自己實際的操作系統，去寫這個代碼！<br>\n另外指定下<br>\nifr.ifr_flags = (IFF_TUN | IFF_NO_PI | IFF_MULTI_QUEUE)<br>\n<br>\n重點説下IFF_TUN，這個表示虛擬網卡工作在IP層，如果用來TAP，表示工作在數據鏈路層<br>\nIP層的單位是包【packet】，數據鏈路層的單位是幀【frame】<br>\n<br>\n如何對這個虛擬網卡讀寫數據呢？<br>\n寫數據<br>\nwrite(fd, buffer, buflen));<br>\n<br>\n讀數據<br>\nread(fd, buffer, &amp;buflen);<br>\n<br>\n2.2 我們實現第二部分，網絡通信<br>\n這個就是很容易了，比較隨意<br>\n最簡單，就是把讀到的buffer，直接tcp發出去，再用tcp收buffer<br>\n然後，把buffer，寫回虛擬網卡<br>\n<br>\n當然，也可以用v2ray封裝一下，通過v2ray的 payload來發送，<br>\n也可以用shadowsocks發送，也可以用https。。。。<br>\n<br>\n今天我們重點講wireguard，所以底層協議就用wireguard了~<br>\n<br>\nwireguard，基於noise 協議框架，所以我們建一個noise的class","date":"2020-05-01","agreeCount":0,"discussionCount":0}