{"type":"video_comment","id":17752,"parentType":"video","parentId":1872,"uid":18160,"contents":"參考資料<br>\nhttps://noiseprotocol.org<br>\nhttps://www.wireguard.com/protocol/<br>\n<br>\n我們繼續詳細設計的網絡通信部分<br>\n<br>\n首先，根據文檔，我們需要實現握手協議<br>\nhandshake<br>\n<br>\n所以，我們的noise這個class需要有一個handshake方法<br>\n<br>\n因爲wireguard，是peer to peer方式，沒有服務器和客戶端的概念。<br>\n<br>\n這裏有一個發起方，和回應方<br>\nFirst Message: Initiator to Responder<br>\n第一條消息，由發起方，發送 handshake initiator消息給對端【這裏應該是你發給VPN產商的地址】<br>\nSecond Message: Responder to Initiator<br>\n第二條消息，由回應方，返回handshake response消息給我們【VPN產商返回給我們】<br>\n<br>\n這裏，就完成了握手~<br>\n後面的都是數據交換包【通過ChaCha20-Poly1305加密】<br>\nSubsequent Messages: Exchange of Data Packets<br>\n<br>\n<br>\n先説第一個包怎麽寫吧~<br>\n<pre>msg = handshake_initiation {<br>\n&nbsp; &nbsp; u32 message_type // 寫死 1 不可能其他值<br>\n&nbsp; &nbsp; u32 sender_index // 一個計數器，每次握手包，自己+1<br>\n&nbsp; &nbsp; u8 unencrypted_ephemeral[32]&nbsp; //我們的公鑰。明文，否則對端沒有辦法知道我們的公鑰<br>\n&nbsp; &nbsp; u8 encrypted_static[AEAD_LEN(32)] // 加密的内容，後面講<br>\n&nbsp; &nbsp; u8 encrypted_timestamp[AEAD_LEN(12)] //加密的時間戳<br>\n&nbsp; &nbsp; u8 mac1[16]&nbsp; // 算一次摘要<br>\n&nbsp; &nbsp; u8 mac2[16]&nbsp; // 再算一次摘要<br>\n}</pre><br>\n<br>\n<pre>msg.encrypted_static = AEAD(key, 0, initiator.static_public, initiator.hash)</pre><br>\nAEAD 表示chacha20-poly1305加密算法，我們不需要自己實現，直接NSS【火狐自帶的TLS實現】就好了<br>\nkey從哪裏來呢？回歸我前面說的HKDF算法~<br>\n<pre>initiator.chaining_key = HASH(CONSTRUCTION) <br>\n// CONSTRUCTION = “Noise_IKpsk2_25519_ChaChaPoly_BLAKE2s” 字符串什麽意思，你得去讀下Noise協議框架的入門知識了，表示這個協議内容是怎麽定義的。<br>\n// HASH 表示 Blake2s 算法<br>\n// 寫死[96, 226, 109, 174, 243, 39, 239, 192, 46, 195, 53, 226, 160, 37, 210, 208, 22, 235, 66, 6, 248, 114, 119, 245, 45, 56, 209, 152, 139, 120, 205, 54]; 對CONSTRUCTION做blake2s算hash是結果一樣的，沒必要每次算<br>\ninitiator.hash = HASH(HASH(initiator.chaining_key || IDENTIFIER) || responder.static_public)<br>\n// IDENTIFIER = \"WireGuard v1 zx2c4 Jason@zx2c4.com\"<br>\n// HASH(initiator.chaining_key || IDENTIFIER) 寫死&nbsp; [34, 17, 179, 97, 8, 26, 197, 102, 105, 18, 67, 219, 69, 138, 213, 50, 45, 156, 108, 102, 34, 147, 232, 183, 14, 225, 156, 101, 186, 7, 158, 243];<br>\n和服務器的公鑰或運算后，再算一次blake2s<br>\n<br>\ninitiator.hash = HASH(initiator.hash || msg.unencrypted_ephemeral)<br>\n把剛才的hash和自己的公鑰，算一次或，然後再算一次hash<br>\ntemp = HMAC(initiator.chaining_key, msg.unencrypted_ephemeral)<br>\ninitiator.chaining_key = HMAC(temp, 0x1)<br>\n// 得到HKDF的PRF<br>\n<br>\ntemp = HMAC(initiator.chaining_key, DH(initiator.ephemeral_private, responder.static_public))<br>\ninitiator.chaining_key = HMAC(temp, 0x1)<br>\nkey = HMAC(temp, initiator.chaining_key || 0x2)<br>\n// HKDF 的extend 得到 最終的密鑰<br>\n</pre><br>\nHMAC 表示Blake2s【和sha256一樣算摘要的】，NSS裏也有了~<br>\n<br>\n寫的真複雜啊。。。<br>\n<br>\n<pre>initiator.hash = HASH(initiator.hash || msg.encrypted_static)</pre><br>\n<br>\n然後繼續算hash 。。。<br>\n<br>\n<br>\n繼續剛才的過程，計算一次新的key，用新的key，加密時間戳。。。<br>\n再根據協議，算一次mac【blake2b摘要】<br>\n第二次mac，是和cookie有關，先不講。。。<br>\n<br>\n。。。。<br>\n<br>\n<br>\nresponse的協議，怎麽拼，也一樣<br>\n<br>\n<br>\n<br>\n<br>\n我就是對報文怎麽拼，給你講一遍。。。<br>\n不可能所有協議都講<br>\n<br>\n<br>\n要學會舉一反三！！！<br>\n自己根據https://www.wireguard.com/protocol/<br>\n<br>\n把所有協議自己實現掉。。。<br>\n當然可以和我一樣，用現成的v2ray或者shadowsocks<br>\n<br>\n這樣就不用自己寫協議層了。。。<br>\n-----------------------------------<br>\n我更多是告訴大家，這裏需要實現網絡通信協議<br>\n具體什麽協議，你們自己看著辦，<b>不被GFW識別就行了</b><br>\n<br>\n我建議別用裸的Wireguard，流量特徵太明顯了<br>\n如果我是GFW，我會把所有UDP報文長度是92的包，無條件扔掉~<br>\n<br>\n然後，我也大概告訴大家，自己寫協議，需要怎麽寫代碼<br>\n大概流程給了一個模板","date":"2020-05-01","agreeCount":0,"discussionCount":0}