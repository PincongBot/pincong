{"type":"video_comment","id":15563,"parentType":"video","parentId":1562,"uid":18160,"contents":"解释下DoH发起的时候，有没有ESNI的问题。<br>\n<br>\n首先DoH的地址，可以是这样的 <a href=\"https://1.1.1.1/dns-query\" rel=\"nofollow noreferrer noopener\" target=\"_blank\">https://1.1.1.1/dns-query</a><br>\n<br>\n也是可以 <a href=\"https://dns.couldflare-dns.com/dns-query\" rel=\"nofollow noreferrer noopener\" target=\"_blank\">https://dns.couldflare-dns.com/dns-query</a> 这样的<br>\n<br>\n如果是第一种情况，因为是IP地址，自然不存在SNI，也就不可能存在ESNI<br>\n<br>\n如果是第二种情况，因为是域名，所以要先去查这个域名的具体IP，也就是用传统的DNS查找<br>\n<br>\n在about:config配置页，输入 network.trr.bootstrapAddress 这个配置后面填入具体的DNS地址<br>\n<br>\n完整过程就是火狐，先从network.trr.bootstrapAddress 配置的DNS地址，查找具体的IP，再发起TLS连接。这个时候，没有使用DoH，用的是传统的DNS，所以SNI没有加密<br>\n<br>\n火狐使用ESNI，必须配合DoH，使用<b>传统的DNS是无效</b>的<br>\n<br>\n<br>\n传统过程：<br>\n<br>\n1.火狐向传统DNS请求 Google的IP地址<br>\n<br>\n2.火狐连接得到的IP地址，并给出带SNI的ClientHello<br>\n<br>\n3.正常浏览网页<br>\n<br>\nDoH + ESNI过程<br>\n<br>\n1.火狐通过DoH请求Google的IP地址，并得到TXT record<br>\n<br>\n2.火狐根据TXT record得到公钥，和自己的私钥，计算得到AEAD的密钥<br>\n<br>\n3.火狐用AEAD密钥加密了SNI<br>\n<br>\n4.火狐连接Google的IP地址，并发起TLS握手，其中SNI字段被加密了<br>\n<br>\n5.正常浏览网页<br>\n<br>\n代码流程：<br>\n<br>\n第一步<br>\n<br>\nfirefox\\netwerk\\dns\\TRR.cpp 文件的 TRR::SendHTTPRequest() 发起了DoH请求，查询服务器的IP地址<br>\n<br>\n同文件的TRR::On200Response(nsIChannel* aChannel)函数解析了DoH的应答，根据TXT字段，设置了公钥<br>\n<br>\n第二步<br>\n<br>\nfirefox\\security\\nss\\lib\\ssl\\tls13esni.c 文件的 SSLExp_SetESNIKeyPair 把得到的record记录，设置到 ss-&gt;esniKeys = keys; 里去，完成了服务器公钥的设置<br>\n<br>\n第三步<br>\n<br>\nfirefox\\security\\nss\\lib\\ssl\\ssl3con.c 文件的 tls13_SetupClientHello 开始组装ClientHello报文，和ESNI相关的这行<br>\n<br>\n<pre>rv = tls13_ClientSetupESNI(ss);<br>\n</pre><br>\nfirefox\\security\\nss\\lib\\ssl\\tls13esni.c的tls13_ClientSetupESNI函数 调用 tls13_CreateKeyShare函数，得到<br>\n<br>\n<pre>&nbsp; &nbsp; ss-&gt;xtnData.esniPrivateKey = keyPair;<br>\n&nbsp; &nbsp; ss-&gt;xtnData.esniSuite = suite;<br>\n&nbsp; &nbsp; ss-&gt;xtnData.peerEsniShare = share;<br>\n</pre><br>\n第四步<br>\n<br>\nfirefox\\security\\nss\\lib\\ssl\\ssl3ext.c 文件的 ssl_ConstructExtensions 开始组装clienthello的ext部分<br>\n<br>\n重点是<br>\n<br>\n<pre>rv = (*sender-&gt;ex_sender)(ss, &amp;ss-&gt;xtnData, buf, &amp;append);<br>\n</pre><br>\n其中 ex_sender 函数指针指向 static const ssl3ExtensionHandler clientHelloHandlers[] 的 ex_sender<br>\n<br>\n因为我们关心的是ESNI，所以看 tls13_ServerHandleEsniXtn， 每种ext都有自己的ex_sender函数，挺方便扩展的<br>\n<br>\n第五步<br>\n<br>\nfirefox\\security\\nss\\lib\\ssl\\tls13exthandle.c 文件的tls13_ClientSendEsniXtn函数<br>\n<br>\n<pre>aead = tls13_GetAead(ssl_GetBulkCipherDef(suiteDef));<br>\n</pre><br>\n得到了具体的aead算法加密函数，并调用 tls13_ComputeESNIKeys 得到了AEAD的密钥<br>\n<br>\n<pre>&nbsp; &nbsp; rv = aead(&amp;keyMat, PR_FALSE /* Encrypt */,<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; outBuf, &amp;outLen, sizeof(outBuf),<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SSL_BUFFER_BASE(&amp;sni),<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SSL_BUFFER_LEN(&amp;sni),<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SSL_BUFFER_BASE(&amp;aadInput),<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SSL_BUFFER_LEN(&amp;aadInput));<br>\n</pre><br>\n最后调用aead函数加密sni，得到esni字符串outBuf，并完成最后的ext组装！<br>\n<br>\n<br>\ndig TXT pincong.rocks +short<br>\n这条命令，可以查到 pincong 的esni record","date":"2020-04-12","agreeCount":2,"discussionCount":0}