{"type":"article","id":1185,"title":"Topcoder SRM 605 div1 题解","uid":4065,"topics":[406],"contents":"Easy（250pts）：<br>\n题目大意：你有n种汉堡包（统统吃掉～），每一种汉堡包有一个type值和一个taste值，你现在要吃掉若干个汉堡包，使得它们taste的总和*（不同的type值的个数）乘积越大，输出这个最大值。数据满足n&lt;=50,type&lt;=100,abs(taste)&lt;=100000。<br>\n这题好像是个贪心，才不是呢啊哼～<br>\n首先我们发现，如果若干个汉堡包有同一个type值，那么我们可以把这一些汉堡包看成一个新的大汉堡包，它的type就是原来的type，它的taste就是取原先至少一个的最大taste之和，显然这一步是可以O(n)预处理完成的。<br>\n然后由于type不是很大，我们可以枚举我们选取了多少个type，<br>\n如果选择了k个type，那么一定是选择了taste最大的k个，然后乘以下，扫一遍k就好了。<br>\n时间复杂度O(n^2)，代码如下：<br>\n<br>\n<pre>#include &lt;bits/stdc++.h&gt;<br>\n#define Maxn 107<br>\n#define inf 10000007<br>\nusing namespace std;<br>\nint f[Maxn],g[Maxn];<br>\nint cnt1,cnt2,n;<br>\nclass AlienAndHamburgers<br>\n{<br>\n    public:<br>\n    int getNumber(vector &lt;int&gt; type, vector &lt;int&gt; taste)<br>\n    {<br>\n        n=type.size();<br>\n        for (int i=1;i&lt;=100;i++)<br>\n            f[i]=-inf;<br>\n        for (int i=0;i&lt;n;i++)<br>\n            if (f[type[i]]&lt;0) f[type[i]]=max(f[type[i]],taste[i]);<br>\n            else if (taste[i]&gt;0) f[type[i]]+=taste[i];<br>\n        sort(f+1,f+100+1);<br>\n        memset(g,0,sizeof(g));<br>\n        g[100]=f[100];<br>\n        for (int i=100-1;i;i--)<br>\n            g[i]=f[i]+g[i+1];<br>\n//g[100+1-i] now means the most taste[i] can get to choose i types of food<br>\n        int ans=0;<br>\n        for (int i=1;i&lt;=100;i++)<br>\n            if (f[100+1-i]&gt;-inf&amp;&amp;g[100+1-i]&gt;0) ans=max(ans,g[100+1-i]*i);<br>\n        return ans;<br>\n    }<br>\n};</pre><br>\n<br>\nMedium（450pts）：<br>\n题目大意：有2n个数1~2n，现在把它们分成两个集合A和B，满足A和B都有n个元素，且A中第i小的元素和B中第i小的元素的差的绝对值至少为K，求方案数，数据满足n&lt;=50,K&lt;=10。<br>\n我实在没有搞懂，为什么这题450分。。。<br>\n比较显然是个dp吧，我们来考虑怎么来描述一个状态，<br>\n在每一个状态下，都有两种数，第一种是已经被匹配的了，第二种是还没有被匹配的，<br>\n而没有被匹配的也有两种，<br>\n我们从大到小进行匹配，假设当前进行匹配的数为i，那么未被匹配的数一共有两种，<br>\n第一种是大于等于i+K的数，这些数可以随意被匹配，<br>\n第二种是i+1~i+K-1这些数，这些数不能和i匹配，<br>\n这两种数中，第一种数我们只关心它的个数，第二种则要关心位置，需要用2^k种状态描述出来，<br>\n然后直接转移就可以了，<br>\n时间复杂度O(n^2*2^K)，代码如下：<br>\n<pre>#include &lt;bits/stdc++.h&gt;<br>\n#define modp 1000000007<br>\n#define Maxn 107<br>\n#define Maxk 10<br>\nusing namespace std;<br>\nint f[Maxn][Maxn][1&lt;&lt;Maxk];<br>\nbool vis[Maxn][Maxn][1&lt;&lt;Maxk];<br>\nint n,k;<br>\nclass AlienAndSetDiv1<br>\n{<br>\n&nbsp; &nbsp; int tryit(int i, int j, int t)<br>\n&nbsp; &nbsp; {<br>\n//i means how many numbers left now<br>\n//j means how many numbers in set A can be free-matched<br>\n//t means the condition of the numbers in set A that cannot be free-matched<br>\n&nbsp; &nbsp; &nbsp; &nbsp; if (vis[i][j][t]) return f[i][j][t];<br>\n&nbsp; &nbsp; &nbsp; &nbsp; vis[i][j][t]=true;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; int res=0;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; if (i==0)<br>\n&nbsp; &nbsp; &nbsp; &nbsp; {<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (j==0&amp;&amp;t==0) res=1;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f[i][j][t]=res;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return res;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; }<br>\n&nbsp; &nbsp; &nbsp; &nbsp; if (j==0&amp;&amp;t==0)<br>\n&nbsp; &nbsp; &nbsp; &nbsp; {<br>\n//all the i numbers are matched now<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (k==1) res=tryit(i-1,1,0); else res=tryit(i-1,0,1);<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res=(2LL*res)%modp;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f[i][j][t]=res;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return res;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; }<br>\n&nbsp; &nbsp; &nbsp; &nbsp; if (j&gt;0)<br>\n&nbsp; &nbsp; &nbsp; &nbsp; {<br>\n//i get matched with a free-matched one<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int nowt=2*t,nowj=j-1;<br>\n//the biggest one become free-matched<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (nowt&amp;(1&lt;&lt;(k-1)))<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nowt-=1&lt;&lt;(k-1);<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++nowj;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; res=(res+tryit(i-1,nowj,nowt))%modp;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; }<br>\n&nbsp; &nbsp; &nbsp; &nbsp; int nowt=2*t+1,nowj=j;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; if (nowt&amp;(1&lt;&lt;(k-1)))<br>\n&nbsp; &nbsp; &nbsp; &nbsp; {<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; nowt-=1&lt;&lt;(k-1);<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ++nowj;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; }<br>\n&nbsp; &nbsp; &nbsp; &nbsp; res=(res+tryit(i-1,nowj,nowt))%modp;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; f[i][j][t]=res;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; return res;<br>\n&nbsp; &nbsp; }<br>\n&nbsp; &nbsp; public:<br>\n&nbsp; &nbsp; int getNumber(int N, int K)<br>\n&nbsp; &nbsp; {<br>\n&nbsp; &nbsp; &nbsp; &nbsp; n=N,k=K;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; memset(vis,false,sizeof(vis));<br>\n&nbsp; &nbsp; &nbsp; &nbsp; memset(f,0,sizeof(f));<br>\n&nbsp; &nbsp; &nbsp; &nbsp; return tryit(2*n,0,0);<br>\n&nbsp; &nbsp; }<br>\n};</pre><br>\nHard（1000pts）：<br>\n题目大意：现在有一个数列，它是1~n的一个排列，我们每次可以进行一次操作：选取一段l~r，将l~r的数都变成l~r的最大值，现在可以进行不超过K次操作，求最后一共有多少种不同的可能。数据满足n&lt;=200,k&lt;=200。<br>\n怎么这题又是dp呀，自古TC出DP～<br>\n在dp之前，我们需要对这个奇奇怪怪的操作挖掘一些性质。<br>\n首先，一开始的n个数是不相同的，所以在整个操作过程中的任何时刻，相同的数永远都是连续的一段。<br>\n其次，在某次操作前，i的一段在j的一段的前面，那么操作之后i的这一段依然在j的这一段的前面。<br>\n有了这两个性质，差不多就可以dp了，我们考虑如何表述一个状态。<br>\nk表示当前最多可以操作几步，i表示当前从小到大判定第几个数，j表示新的数列的前j个数已经被确定，<br>\n那么我们就有f[k][i][j]=sigma(f[k-1][i-1][r])。<br>\n然而这样是O(n^4)的，对于n&lt;=200显然会爆炸，我们考虑进行进一步的优化，<br>\n我们预处理出第i为什么情况下能变成j，那么一定是在原数列中，这两个数位置之前的数都小于等于j，<br>\n这样我们可以先预处理出某个位置可以变成什么数，时间复杂度O(n^3)，<br>\n然后我们继续dp，除了上面描述的k,i,j，我们再用一个state表示当前是否处于匹配状态，显然state只能是true或者false，<br>\n于是考虑f[k][i][j][state]：<br>\n如果j&gt;n，那么这已经是一个合法方案了，直接返回1；<br>\n如果i&gt;n，那么这个方案不合法，直接返回0；<br>\n如果这两种情况都不满足，那么有两种情况：<br>\n第一种是当前数i不参与匹配，对答案贡献度是f[k][i+1][j][false]；<br>\n第二种是当前数i参与匹配，我们没有必要再枚举它匹配到哪个位置，直接f[k-1][i][j+1][true]就可以了。<br>\n这里dp就完成了，时间复杂度O(n^3)。<br>\n所以整个题时间复杂度O(n^3)，代码如下：<br>\n<pre>#include &lt;bits/stdc++.h&gt;<br>\n#define Maxn 207<br>\n#define modp 1000000007<br>\nusing namespace std;<br>\nint f[Maxn][Maxn][Maxn][2];<br>\nbool vis[Maxn][Maxn][Maxn][2];<br>\nbool check[Maxn][Maxn];<br>\nint p[Maxn];<br>\nint n,k;<br>\nclass AlienAndPermutation<br>\n{<br>\n&nbsp; &nbsp; int tryit(int k, int i, int j, int state)<br>\n&nbsp; &nbsp; {<br>\n&nbsp; &nbsp; &nbsp; &nbsp; if (vis[k][i][j][state]) return f[k][i][j][state];<br>\n&nbsp; &nbsp; &nbsp; &nbsp; vis[k][i][j][state]=true;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; if (j&gt;n)<br>\n&nbsp; &nbsp; &nbsp; &nbsp; {<br>\n//the situation is valid<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f[k][i][j][state]=1;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return f[k][i][j][state];<br>\n&nbsp; &nbsp; &nbsp; &nbsp; }<br>\n&nbsp; &nbsp; &nbsp; &nbsp; if (i&gt;n)<br>\n&nbsp; &nbsp; &nbsp; &nbsp; {<br>\n//the situation is invalid<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; f[k][i][j][state]=0;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return f[k][i][j][state];<br>\n&nbsp; &nbsp; &nbsp; &nbsp; }<br>\n//the ith number isn't used<br>\n&nbsp; &nbsp; &nbsp; &nbsp; int res=tryit(k,i+1,j,0);<br>\n//the ith number is used<br>\n&nbsp; &nbsp; &nbsp; &nbsp; if (check[i][j])<br>\n&nbsp; &nbsp; &nbsp; &nbsp; {<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (state==1||(i==j)) res=(res+tryit(k,i,j+1,state))%modp;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; else if (k&gt;0) res=(res+tryit(k-1,i,j+1,1))%modp;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; }<br>\n&nbsp; &nbsp; &nbsp; &nbsp; f[k][i][j][state]=res;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; return res;<br>\n&nbsp; &nbsp; }<br>\n&nbsp; &nbsp; public:<br>\n&nbsp; &nbsp; int getNumber(vector &lt;int&gt; P, int K)<br>\n&nbsp; &nbsp; {<br>\n&nbsp; &nbsp; &nbsp; &nbsp; n=P.size(),k=K;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; for (int i=1;i&lt;=n;i++) p[i]=P[i-1];<br>\n&nbsp; &nbsp; &nbsp; &nbsp; memset(check,true,sizeof(check));<br>\n&nbsp; &nbsp; &nbsp; &nbsp; for (int i=1;i&lt;=n;i++)<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int j=1;j&lt;=n;j++)<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int t=min(i,j);t&lt;=i||t&lt;=j;t++)<br>\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (p[t]&gt;p[i]) check[i][j]=false;<br>\n&nbsp; &nbsp; &nbsp; &nbsp; memset(f,0,sizeof(f));<br>\n&nbsp; &nbsp; &nbsp; &nbsp; memset(vis,false,sizeof(vis));<br>\n&nbsp; &nbsp; &nbsp; &nbsp; return tryit(k,1,1,0);<br>\n&nbsp; &nbsp; }<br>\n};</pre>","date":"2019-04-09","agreeCount":-1,"discussionCount":0}