{"type":"article","id":23745,"title":"在文字转图片发送信息时，防止OCR审查的办法","uid":42325,"topics":[199,833],"contents":"&nbsp; &nbsp; &nbsp; &nbsp; 这个问题起于自己与人聊某些相对不算敏感，但可能会被抓关键字的话题时的一些思考：通过文字转图片，能够避免机器对自己聊天的审核么？（鉴于VX的数据量，几乎不可能安排人工审核去审核升斗小民的聊天记录）<br>\n<br>\n&nbsp; &nbsp; &nbsp; &nbsp; 经过测试，常见的OCR引擎中，似乎腾讯的识别效果是最佳的，通过加噪点等方式，几乎无法对其进行干扰，因此而产生了新的思路，即使用颜色较浅的文字对机器进行误导<br>\n<br>\n&nbsp; &nbsp; &nbsp; &nbsp; 在之后的测试中，发现这种方法对机器的误导也并不算严重，除非将干扰用的文字颜色加深到影响人类阅读的地步，否则很难对机器造成有效干扰<br>\n<br>\n&nbsp; &nbsp; &nbsp; &nbsp; 最后又经过一段时间研究，终于得出一个能较为有效欺骗市面常见OCR引擎的方式，这种方法需要做到以下几点：<br>\n&nbsp; &nbsp; &nbsp; &nbsp; 1.真实信息所用的文字比较少见，如行书或各类手写体，此时由于对AI模型训练时，输入的该种字体样本较少，AI会相对更难以准确识别文字<br>\n&nbsp; &nbsp; &nbsp; &nbsp; 2.干扰用文字需用更加“标准”的字体，如宋体、楷体等<br>\n&nbsp; &nbsp; &nbsp; &nbsp; 3.干扰用信息贴近图片边框绘制，而真实信息则距离边框拉开一些距离，让AI首先看到干扰用的文字<br>\n<br>\n&nbsp; &nbsp; &nbsp; &nbsp; 最后的结果如下图，目前个人还没有找到能有效识别图中文字的商用OCR引擎，该图片只需稍稍放大一些，就可以很清晰的识别出真正的文字<br>\n<a href=\"https://i.imgur.com/qnCBaaF.png\" rel=\"nofollow noreferrer noopener\" target=\"_blank\"><img src=\"https://i.imgur.com/qnCBaaF.png\" alt=\"https://i.imgur.com/qnCBaaF.png\" style=\"max-width:100%\"></a><br>\n<br>\n<br>\n最后附上测试用的代码，有兴趣的可以用GIN之类做成BS程序方便手机等设备使用<br>\n<br>\n更新：更新了代码，语言由GO换成PYTHON，可以通过命令提示符直接调用，命令格式：<br>\n<blockquote>python AntiOCR.py 真实文本 干扰用文本</blockquote><br>\n更新后代码会根据文本长度自动计算图片长度等，然后自动保存到脚本目录，并根据真实信息MD5码命名<br>\n<br>\n<br>\n#encoding:utf-8<br>\n<br>\nfrom PIL import Image<br>\nfrom PIL import ImageDraw<br>\nfrom PIL import ImageFont<br>\nimport sys<br>\nimport random<br>\nimport time<br>\nimport hashlib<br>\n<br>\n<br>\n# 从干扰字符串中随机截取一段<br>\ndef subStr(str):<br>\n&nbsp; &nbsp; random.seed(time.time() + random.randint(63256, 49896594))<br>\n&nbsp; &nbsp; r = random.randint(0, len(str))<br>\n&nbsp; &nbsp; while r &gt;= len(str) - 18:<br>\n&nbsp; &nbsp; &nbsp; &nbsp; r = random.randint(1, len(str))<br>\n&nbsp; &nbsp; return str[r:r + 18]<br>\n<br>\n#获取MD5值<br>\ndef getMD5(str):<br>\n&nbsp; &nbsp; md5Helper=hashlib.md5()<br>\n&nbsp; &nbsp; md5Helper.update(str.encode(\"utf-8\"))<br>\n&nbsp; &nbsp; ret=md5Helper.hexdigest()<br>\n&nbsp; &nbsp; return ret<br>\n<br>\n# 参数定义<br>\ntrueStr = sys.argv[1]<br>\ndisturbStr = sys.argv[2]<br>\nif len(disturbStr) &lt; 20:<br>\n&nbsp; &nbsp; disturbStr = \"秦孝公据殽函之固，拥雍州之地，君臣固守以窥周室，有席卷天下，包举宇内，囊括四海之意，并吞八荒之心。\"<br>\nfontFileD = sys.path[0] + \"\\\\新宋体.ttc\"<br>\nfontFileT = sys.path[0] + \"\\\\司马彦行书.ttf\"<br>\nwidth = 600<br>\n<br>\n# 参数计算<br>\nrow = len(trueStr) // 17 + 1<br>\nheight = 20 + row * 32<br>\n<br>\n# 创建对象<br>\nimg = Image.new('RGB', (width, height), (255, 255, 255))<br>\nfontD = ImageFont.truetype(fontFileD, 32)<br>\nfontT = ImageFont.truetype(fontFileT, 32)<br>\ndraw = ImageDraw.Draw(img)<br>\n<br>\n# 绘制干扰文本<br>\nfor i in range(row + 1):<br>\n&nbsp; &nbsp; draw.text((3, 3 + i * 32), subStr(disturbStr), (37, 55, 186), fontD)<br>\n<br>\n# 绘制真实文本<br>\nindex = 0<br>\nrowNow = 0<br>\nwhile index &lt; len(trueStr):<br>\n&nbsp; &nbsp; if index + 17 &lt;= len(trueStr):<br>\n&nbsp; &nbsp; &nbsp; &nbsp; draw.text((10, 10 + 32 * rowNow), trueStr[index:index + 17], (0, 0, 0), fontT)<br>\n&nbsp; &nbsp; else:<br>\n&nbsp; &nbsp; &nbsp; &nbsp; draw.text((10, 10 + 32 * rowNow), trueStr[index:], (0, 0, 0), fontT)<br>\n&nbsp; &nbsp; index = index + 17<br>\n&nbsp; &nbsp; rowNow = rowNow + 1<br>\n<br>\n# 显示图片<br>\n# img.show()<br>\n<br>\n# 保存图片<br>\nimg.save(getMD5(trueStr)+\".jpg\", \"jpeg\")","date":"2020-09-04","agreeCount":7,"discussionCount":0}